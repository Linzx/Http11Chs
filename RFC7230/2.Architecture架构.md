   HTTP是为构建万维网(World Wide Web, WWW)架构而提出的, 经过长时间的演进, 已经能够支持全球规模的超文本系统的各类需求. 架构的很多部分都能够从HTTP的术语和语法上得到体现.

#### 2.1. C/S架构消息

   HTTP是一个无状态的请求/回复协议, 通过一个可靠的传输/会话层「连接」(第6章)交换消息(第3章). 一个HTTP「客户端」(client)是为了发送一个或多个请求, 而与服务器建立了连接(connection)的程序. 一个HTTP「服务器」(server)也是一个程序, 它接受来自客户端的连接, 服务这些客户端的HTTP请求并返回HTTP回复.

   术语「客户端」和「服务器」仅仅是为了区分一个特定连接中不同程序扮演的角色. 同一个程序可以在某些连接中扮演客户端, 而在另一些连接中扮演服务器. 术语「用户代理」(user agent)指代任何一个可以初始化请求的客户端, 包括但不限于浏览器、网络爬虫、命令行工具、定制程序、移动应用等. 对于一个给定的目标资源, 「原始服务器」(origin server)是能对该资源进行权威回复的源头. 术语「发送端」(sender)和「接收端」(recipient)则分别代表发送和接收消息的任意实现.

   HTTP依赖统一资源描述符(Uniform Resource Identifier, URI)来标识目标资源, 以及资源之间的关系. 消息在传输时使用的格式与互联网邮件(Internet mail)、多用途互联网邮件扩展(Multipurpose Internet Mail Extensions, MIME)使用的类似, 查阅附录A以了解它们之间的差异.

   多数HTTP通信中, 存在对指定资源的拉取操作(即GET操作), 这些资源就是通过URI来标识的. 最简单的情况, 这个过程仅需要用户代理(user agent, UA)和原始服务器(O)之间的一个双向连接即可完成.

   >            请求   >
   >    UA ======================================= O
   >                                <   回复

   一个客户端发送给服务器的请求消息依序包含以下内容: 
   - 一个请求行, 包含一个方法, URI, 协议版本;
   - 消息头部, 由一系列消息头部字段组成, 包含请求修饰器(request modifier), 客户端信息, 表征元数据(representation metadata), 消息头部字段以一个空行结尾;
   - 包含有效载荷的消息体(body), 消息体可能为空.

   一个发送一个或多个HTTP回复消息来应答客户端的请求. 回复消息依序包含以下内容：
   - 一个状态行, 包含一个协议版本号, 一个成功/错误码, 成功/错误码的文本解释;
   - 可选的消息头部, 由一系列消息头部字段组成, 包含服务器信息, 资源元数据, 表征元数据, 消息头部字段以一个空行结尾;
   - 包含有效载荷的消息体(body), 消息体可能为空.

   一个连接可以被多轮「请求-回复」复用.

   下面给出一个URI「http://www.example.com/hello.txt」的GET请求示例.

   客户端请求:

   >  GET /hello.txt HTTP/1.1
   >  User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
   >  Host: www.example.com
   >  Accept-Language: en, mi   
   
   服务器回复:

   >  HTTP/1.1 200 OK
   >  Date: Mon, 27 Jul 2009 12:28:53 GMT
   >  Server: Apache
   >  Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
   >  ETag: "34aa387-d-1568eb00"
   >  Accept-Ranges: bytes
   >  Content-Length: 51
   >  Vary: Accept-Encoding
   >  Content-Type: text/plain
   >
   >  Hello World! My payload includes a trailing CRLF.

####2.2. 实现差异

   当设计一个HTTP设计, 很容易陷入一个误区, 认为所有的用户代理都是全功能的浏览器, 所有的原始服务器都是大型的公共站点. 现实的情况不是这样的. 典型的用户代理包括日常使用的应用, 立体声音响(stereos?), 电子秤(scales?), 固件升级脚本, 命令行程序, 移动应用, 以及形形色色的通信设备. 类似的, 典型的原始服务器包括家庭自动化系统, 可配置网路组件, 办公机器, 自治机器人, 新闻聚合器, 电子警察, 广告选择器, 视频分发平台等. 

   术语「用户代理」并不意味着, 需要人类用户与软件代理直接交互才能发起请求. 在很多情况下, 用户代理运行在后台, 保存请求结果以供后续使用, 保存的结果可能只是原始结果中感兴趣的部分或者错误信息. 爬虫就是一种典型的用户代理, 给其一个起始URI, 配置链接跟随的行为模式, 就能在超链接形成的图中, 自动运行下去.

   HTTP实现的差异性意味着并不是所有的用户代理都能以界面交互的方式为用户提供建议, 或者在出现安全和隐私问题时给出足够的警示信息. 如果本文档规定一些错误信息必须向用户汇报时, 可以仅将错误记录在错误输出终端或日志文件中. 同样, 一些需要用户确认才能继续的操作, 可以通过高级配置选项, 运行时选项, 不安全选项的方式进行确认. 如果用户已经做过选择, 这种确认可以不必反馈在用户界面或者打断正常的处理流程. (译者注: 就是说, 用户代理可以根据配置选项, 或过去的选择结果, 代替用户进行选择.)

####2.3. 中介

   HTTP允许使用中介程序将连接组织成一条通信链. 常见的中介有代理(proxy)、网关(gateway)、隧道(tunnel)3种. 一些情况下, 一个中介可以扮演原始服务器, 代理, 网关, 或隧道等角色, 并根据每个请求的特征进行角色切换.

   >         >             >             >             >
   >    UA =========== A =========== B =========== C =========== O
   >               <             <             <             <

   上图中, 用户代理和原始服务器间有三个中介, 分别是A, B, C. 每一个请求/回复需要穿过4个独立的连接, 这4个连接形成一条通信链. 这个特征非常重要, 因为一些HTTP通信选项只能在离终端节点最近的非隧道连接上使用. 尽管图中的场景是线性的, 但实际上每一个参与方都可能同时服务于很多连接. 例如, 在处理A请求的同时, B可能接收来自A之外的其它客户端的请求, 转发给除C外的其它服务器. 后续的请求可以使用不同的连接路径进行传输, 连接路径经常因为动态配置或负载均衡的原因发生变化.

   术语「上游」(upstream)和「下游」(downstream)与信息流的传输方向有关: 所有的信息流都是从上游传输到下游. 术语「入站」(inbound)和「出站」(outbound)描述请求路由的方向: 入站和出站分别代表朝向原始路由器和朝向用户代理.

   一个「代理」是一个消息转发代理程序, 对外暴露HTTP接口, 从该接口接收来自客户端的某些类型的绝对URI请求, 并将请求翻译成合适的协议, 以便进一步处理. 有些翻译只需要最低限度的工作, 例如, 代理接收「http」URI请求, 将其翻译成完全不同的应用层协议. 
